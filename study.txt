2023/2/17(금)
build.gradle 그레이들 -> 스프링 부트로 변경 (의존성)
깃, 깃허브 등록

테스트 코드 작성 - JUnit
TDD - Test-Driven-Development
테스트 코드를 작성하는 것을 시작으로 개발 진행 ( 항생 실패하는 테스트 작성 -> 테스트 통과하는 프로덕션 코드 작성 -> 프로덕선 코드 리팩토링 )

단위 테스트는 위의 과정을 지키는 것이 아니라, 기능 단위의 테스트 코드를 작성하는 것을 이야기한다.
테스트 코드로 개발 초기에 문제를 발견할 수 있고, 기능에 대한 불확실성을 감소시켜준다.


2023/2/18(토)
HelloController의 테스트 코드인 HelloControllerTest 작성
확실히 웹 페이지를 키고 확인하는 것보다 상당한 시간 단축이 있음

개발자 라이브러리 Lombook
자바 개발 시 자주 사용하는 게터, 세터, 기본생정자, toString 등을 어노테이션으로 자동 생성해준다.

스프링 부트에서 JPA로 DB 다루기
관계형 데이터베이스를 이용하는 프로젝트에서 객체지향 프로그래밍을 위해 JPA(자바 표준 ORM(Object Relational Mapping)) 기술 사용
+) Batis 는 SQL Mapping 기술이지 ORM 기술이 아니다. ++) Batis -> JPA 라고 생각해보자

사용하게 된 이유
코드가 SQL을 중심으로 돌아간다.
단순 반복 작업이 너무 많아짐
패러다임 불일치 문제
-> 관계형 데이터베이스는 어떻게 데이터를 저장할지에 대해 초점
-> 객체지향 프로그래밍은 메세지를 기반으로 기능과 속성을 한 곳에서 관리

=> SQL 종속적인 개발을 하지 않기 위해

JPA(Java Persistence API)
객체를 관계형 데이터베이스에서 관리하기 위함
인터페이스이기에 구현체인 Hibernate, Eclipse Link 가 필요

위의 구현체들을 더 쉽게 사용하기 위해 추상화 시킨 것이 아래의 것 ( JPA <- Hibernate <- Spring Data JPA )
큰 차이는 없지만 구현체 교체의 용이성과 저장소 교체의 용이성을 염두하고 사용한다.

실무에서의 JPA
높은 러닝 커브 -> 잘 사용하기 위한 지점이 너무 높다( 객체지향 프로그래밍과 관계형 데이터베이스의 이해가 필요 )
그럼에도 사용하는 이유는 높은 보상
CRUD 쿼리 작성 필요 x, 부모-자식 관계 표현, 데이터베이스 간의 관계 표현 등을 알아서 해줌
속도 이슈는 높은 데이터 처리를 하는 곳에서도 잘 사용한다고 함


2023/2/19(일)
Domain 패키지 만들고 Posts 클래스 작성

Entity 클래스에는 절대 Setter 메서드를 만들지 않는다.
-> 클래스의 인스턴스 값들이 어디서 변경되는지를 명확하게 구분하기 위해서

Setter 없이 DB에 데이터 삽입은 어떻게?
생성자를 통해, 값 변경은 해당 이벤트에 맞는 public 메서드를 호출
or @Builder를 통해 빌더 클래스를 사용

실제로 실행한 쿼리를 볼 수 있을까?
-> application.properties, application.yml 파일로 한 줄의 코드로 설정할 수 있다.


2023/2/23(목)
등록/수정/조회 API 작성
Request 데이터 받을 DTO클래스, API 요청받을 Controller클래스, 트랜잭션과 도메인 기능 순서 보장하는 Service클래스
도메인에서 비즈니스 로직을 처리해야 한다.

스프링에서 Bean 주입받는 방법
@Autowired, setter, 생성자 -> 권장하는 방법은 생성자
@RequiredArgsConstructor은 final이 선언된 모든 필드를 인자값으로 하는 생성자를 롬복이 대신해준다.

JPA Auditing으로 생성, 수정시간 자동화 가능








